package SMA.sound;

import javax.vecmath.Point3d;

import com.sun.j3d.utils.geometry.Cylinder;

import Utilities.Movement;
import Utilities.Point;

public class FindNoteTambourFromMovement extends FindNoteFromMovement {

	//private Vector<>
	
	Point3d center_left;
	Cylinder cylinder;
	Point3d center_right;// center is the bottom of the circle
	
	float AXLow = 150;
	float BZLow = 50;
	float AXHi = 250;
	float BZHi = 100;
	float hightLowY=270;
	float hightHighY=420;
	int note;

	//£¨x-x1)^2/A^2+(y-y1)^2/B^2 <0 EXICTE
	
	public FindNoteTambourFromMovement(Movement movement) {
		super(movement);
		center_left=new Point3d(375,270,0); //270-420 high //left point top:130x y350, right: x620 y350
		center_right=new Point3d(970,270,0);//  z== -100 100 // // LEFTx 720 RIGHT x 1220 

		cylinder=new Cylinder(150,245);   //Cylinder(float height, float radius)
		
	}

	@Override
	public void action() {
		
		Point pos=movement.getPos();
		if (IsLeftDrum(pos)){
		//	62 Mute Hi Conga, 63 Open Hi Conga
			
			note = 62;
		}
		
		if (IsRightDrum(pos)){
			// 47 Low-Mid Tom, 48HIGH-Mid Tom 
			note = 47;
		}
		if (IsLeftDrumHi(pos)){
		//	62 Mute Hi Conga, 63 Open Hi Conga
			
			note = 63;
		}
		
		if (IsRightDrumHi(pos)){
			// 47 Low-Mid Tom, 48HIGH-Mid Tom 
			note = 48;
		}
		
		//int note = matchNote();
		
	}
	
	public boolean IsLeftDrum(Point pos){
		double volum=( (pos.X-center_left.x)*(pos.X-center_left.x) ) /(AXLow*AXLow)+( (pos.Z-center_left.z)*(pos.Z-center_left.z) ) /(BZLow*BZLow);
		if (volum<=1 && pos.Y >=hightLowY&& pos.Y <= hightHighY){
			return true;			
		}
				
		return false;
				
		
	}
	
	public boolean IsRightDrum(Point pos){
		double volum=( (pos.X-center_right.x)*(pos.X-center_right.x) ) /(AXLow*AXLow)+( (pos.Z-center_right.z)*(pos.Z-center_right.z) ) /(BZLow*BZLow);
		if (volum<=1 && pos.Y >=hightLowY&& pos.Y <= hightHighY){
			return true;			
		}
				
		return false;
				
		
	}
	public boolean IsLeftDrumHi(Point pos){
		double volum=( (pos.X-center_left.x)*(pos.X-center_left.x) ) /(AXLow*AXLow)+( (pos.Z-center_left.z)*(pos.Z-center_left.z) ) /(BZ*BZ);
		if (volum<=1 && pos.Y >=hightLowY&& pos.Y <= hightHighY){
			return true;			
		}
				
		return false;
				
		
	}
	
	public boolean IsRightDrumHi(Point pos){
		double volum=( (pos.X-center_right.x)*(pos.X-center_right.x) ) /(AX*AX)+( (pos.Z-center_right.z)*(pos.Z-center_right.z) ) /(BZ*BZ);
		if (volum<=1 && pos.Y >=hightLowY&& pos.Y <= hightHighY){
			return true;			
		}
				
		return false;
				
		
	}
	
}
